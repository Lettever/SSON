primary        → NUMBER | STRING | "true" | "false" | "nil"
               | "(" expression ")" ;

private Expr primary() {
  if (match(FALSE)) return new Expr.Literal(false);
  if (match(TRUE)) return new Expr.Literal(true);
  if (match(NIL)) return new Expr.Literal(null);

  if (match(NUMBER, STRING)) {
    return new Expr.Literal(previous().literal);
  }

  if (match(LEFT_PAREN)) {
    Expr expr = expression();
    consume(RIGHT_PAREN, "Expect ')' after expression.");
    return new Expr.Grouping(expr);
  }
}

//match -> matches something and advances to the next token if it matches
//consume -> expects a character, if it is not the expected character it fails, otherwise it consumes it
----

unary          → ( "!" | "-" ) unary
               | primary ;

private Expr unary() {
  if (match(BANG, MINUS)) {
    Token operator = previous();
    Expr right = unary();
    return new Expr.Unary(operator, right);
  }

  return primary();
}
